# **ОБЩЕЕ ОПИСАНИЕ КОМАНД БИБЛИОТЕКИ `rcu`**

## **ОБЩАЯ ИНФОРМАЦИЯ**

Библиотека **`rcu`** (Robot Control Unit) — это специализированный Python-интерфейс для программирования образовательного робота **E6-RCU** в среде **ZMROBO/RoboCode**. Библиотека предоставляет полный набор функций для взаимодействия со всеми компонентами робота: датчиками, моторами, дисплеями, системами связи и периферией.

---

## **СТРУКТУРА И ПРИНЦИПЫ РАБОТЫ**

### **Основные концепции:**
1. **Get-функции** — чтение данных с датчиков и получение информации
2. **Set-функции** — управление исполнительными механизмами
3. **Wait-функции** — синхронное ожидание событий

### **Общие характеристики:**
- **Блокирующие вызовы**: большинство функций работает синхронно
- **Диапазоны значений**: 
  - Мощность моторов: -100 до 100 (%)
  - Углы сервоприводов: 0-180 (°)
  - Расстояния: 0-400 (см)
  - Цвета RGB: 0-255
- **Частота опроса**: 10-20 Гц (рекомендуемая задержка 50-100 мс)
- **Обработка ошибок**: простые функции с минимальной валидацией

---

## **КАТЕГОРИИ КОМАНД**

### **1. ДАТЧИКИ И ВВОД (Get-функции)**

#### **Датчики расстояния** — измерение дистанции до объектов:
- `GetUltrasound()` — ультразвуковой (20-400 см)
- `GetLaserDist()` — лазерный (более точный)
- `GetShortIRDist()` — инфракрасный (10-80 см)
- `GetSmartEyeDist()` — интеллектуальный датчик расстояния

#### **Оптические датчики** — работа со светом и цветом:
- `GetLightSensor()` — уровень освещенности
- `GetColorSensor()` — определение цвета (RGB)
- `GetTraceV2I2C()` — массив датчиков линии (I2C)

#### **Датчики касания/кнопки** — взаимодействие с пользователем:
- `GetLeftButton()/GetRightButton()` — аппаратные кнопки
- `GetTouch()` — сенсорная кнопка
- `GetTouchScreen()/X/Y()` — координаты касания дисплея

#### **Датчики движения и положения** — инерциальные измерения:
- `GetAHRS()` — углы наклона (IMU)
- `GetMagnetic()` — магнитометр (компас)
- `GetMotorCode()` — позиция энкодера мотора

#### **Камеры и компьютерное зрение** — обработка изображений:
- `GetAICamData()` — данные с AI-камеры
- `GetCamRecog()` — распознавание объектов
- `GetGesture()` — распознавание жестов
- `GetFaceRegisterData()` — данные лиц

#### **Беспроводная связь** — коммуникационные модули:
- **Bluetooth**: `GetBluetoothControl()`, `GetBTModuleRemoteButton()`
- **RF**: `GetRFModuleByte()`, `GetRFModuleRemoteRocker()`
- **WiFi**: `GetWifiCamPictureResult()`, `GetWifiPictureData()`

#### **Датчики окружающей среды** — мониторинг условий:
- `GetAirPressure()` — атмосферное давление
- `GetSht30()` — температура и влажность
- `GetInVoltage()` — напряжение питания

#### **Аудио функции** — работа со звуком:
- `GetInMic()` — уровень микрофона
- `GetComVoice()` — голосовые команды

#### **Системные функции** — время и случайность:
- `GetSysTime()` — системное время (секунды)
- `GetRandom()` — случайное число

---

### **2. УПРАВЛЕНИЕ И ВЫВОД (Set-функции)**

#### **Управление моторами** — движение робота:
- `SetMotor(left, right)` — основное управление
- `SetMotorServo(num, angle)` — сервоприводы
- `SetMotorStraight(speed)` — прямое движение
- `SetCarTurn(value)` — управление поворотом

#### **Светодиоды и индикация** — визуальная обратная связь:
- `Set3CLed(num, R, G, B)` — RGB светодиоды
- `SetSmartEyeAllLed(state)` — управление всеми светодиодами
- `SetAICamLED(state)` — подсветка камеры

#### **Дисплей и экран** — вывод информации:
- **Текст**: `SetDisplayString(text, x, y)`
- **Числа**: `SetDisplayInt(value, x, y)`
- **Графика**: `SetLCDLine()`, `SetLCDRectangle2()`
- **Матрица**: `SetDisplayLatticeString()`, `SetDisplayLatticePic()`

#### **Аудио выход** — звуковое сопровождение:
- `SetInBeep(freq, duration)` — одиночный сигнал
- `SetInSound(data)` — произвольный звук
- `SetMp3Play(file)` — воспроизведение MP3

#### **Беспроводная связь (передача)**:
- `SetBluetoothData(data)` — отправка по Bluetooth
- `SetRFModuleByte(data)` — передача RF
- `SetRFPassWord(pass)` — установка пароля

#### **Системные команды**:
- `SetSysTime(seconds)` — установка времени
- `SetWaitForTime(ms)` — ожидание
- `SetFaceRegister()` — регистрация лиц

---

### **3. ФУНКЦИИ ОЖИДАНИЯ (Wait-функции)**

**Блокирующее ожидание событий:**
- `WaitLeftButtonPressed()/Released()` — кнопки
- `WaitTouchPressed()/Released()` — сенсорная панель

**Особенности:**
- Блокируют выполнение до наступления события
- Полезны для синхронного взаимодействия
- Могут иметь таймауты

---

## **ПРИНЦИПЫ ИСПОЛЬЗОВАНИЯ**

### **Базовый шаблон программы:**
```python
import rcu
import time

def main():
    # 1. Чтение датчиков
    distance = rcu.GetUltrasound()
    light = rcu.GetLightSensor()
    
    # 2. Принятие решений
    if distance < 20:
        # 3. Управление моторами
        rcu.SetMotor(-30, -30)
        # 4. Индикация
        rcu.Set3CLed(1, 255, 0, 0)
        # 5. Звуковой сигнал
        rcu.SetInBeep(1000, 200)
    
    # 6. Вывод информации
    rcu.SetDisplayString(f"Dist: {distance}cm", 0, 0)

while True:
    main()
    time.sleep(0.1)  # Важно: задержка для стабильности
```

### **Рекомендации по использованию:**

#### **1. Обработка ошибок:**
```python
try:
    distance = rcu.GetUltrasound()
    if distance > 0:  # Проверка валидности
        # Работа с данными
except:
    print("Ошибка чтения датчика")
```

#### **2. Оптимальные задержки:**
- Основной цикл: 50-100 мс (10-20 Гц)
- Движение моторов: 100-500 мс для маневров
- Опрос датчиков: совмещать в одном цикле

#### **3. Энергоэффективность:**
- Выключать неиспользуемые модули
- Минимизировать яркость дисплея
- Использовать прерывания вместо опроса

#### **4. Безопасность:**
```python
# Всегда останавливать моторы при ошибке
try:
    # Код управления
except:
    rcu.SetMotor(0, 0)  # Аварийная остановка
```

---

## **ПРАКТИЧЕСКИЕ СЦЕНАРИИ ИСПОЛЬЗОВАНИЯ**

### **Образовательные проекты:**
1. **Следование по линии** — `GetTraceV2I2C()` + `SetMotor()`
2. **Избегание препятствий** — `GetUltrasound()` + логика движения
3. **Сортировка по цвету** — `GetColorSensor()` + сервоприводы
4. **Управление по Bluetooth** — `GetBTModuleRemoteRocker()` + двигатели
5. **Распознавание жестов** — `GetGesture()` + реакции робота

### **Исследовательские задачи:**
1. **Картография** — комбинация дальномеров и энкодеров
2. **Навигация** — IMU + компас + одометрия
3. **Мониторинг** — датчики среды + запись данных
4. **Компьютерное зрение** — камера + обработка изображений

---

## **ТИПИЧНЫЕ ОШИБКИ И РЕШЕНИЯ**

### **1. Моторы не реагируют:**
- Проверить питание
- Проверить диапазон значений (-100 до 100)
- Добавить задержку между командами

### **2. Датчики возвращают неверные значения:**
- Калибровка датчиков
- Проверка освещения (для оптических датчиков)
- Избегание помех для беспроводных датчиков

### **3. Программа "зависает":**
- Проверить бесконечные циклы
- Добавить `time.sleep()` в циклы
- Использовать `try-except` для обработки ошибок

### **4. Проблемы с беспроводной связью:**
- Проверить сопряжение устройств
- Убедиться в совместимости протоколов
- Проверить уровень сигнала

---

## **ОГРАНИЧЕНИЯ И ВОЗМОЖНОСТИ**

### **Ограничения:**
1. **Производительность**: Не предназначена для высокочастотного управления
2. **Точность**: Образовательный уровень точности измерений
3. **Память**: Ограниченные ресурсы встроенного контроллера
4. **Параллелизм**: В основном последовательное выполнение

### **Сильные стороны:**
1. **Простота**: Интуитивный API для начинающих
2. **Комплексность**: Полный набор функций "из коробки"
3. **Интеграция**: Готовая работа со всеми компонентами робота
4. **Образовательность**: Идеальна для обучения основам робототехники

---

## **ЗАКЛЮЧЕНИЕ**

Библиотека `rcu` представляет собой **законченное решение** для программирования робота E6-RCU, охватывающее все аспекты: от низкоуровневого управления моторами до сложных задач компьютерного зрения. 

**Ключевые принципы:**
- **Get → Process → Set** — основной цикл работы
- **Модульность** — независимое использование компонентов
- **Образовательная направленность** — упрощенный API для обучения

Библиотека оптимальна для:
- Образовательных учреждений
- Начинающих робототехников
- Быстрого прототипирования
- Демонстрационных проектов

Для промышленных или высокоточных применений рекомендуется использование специализированных библиотек и платформ.
